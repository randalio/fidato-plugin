{"version":3,"file":"js/main.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAkD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,kCAAkC,mDAAmD,IAAI;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;AACA,mCAAmC,wCAAwC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,4BAA4B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY;AACrE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mCAAmC;AACzE,MAAM;AACN,sCAAsC,kCAAkC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC,0CAA0C,uBAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8UAA8U,gBAAgB;AAC9V;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4BAA4B,EAAE,eAAe;AACjF;AACA;AACA;AACA;AACA;AAGE;AACF;;;;;;UCxjCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtB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","sources":["webpack://fidato-wealth/./node_modules/lenis/dist/lenis.mjs","webpack://fidato-wealth/webpack/bootstrap","webpack://fidato-wealth/webpack/runtime/define property getters","webpack://fidato-wealth/webpack/runtime/hasOwnProperty shorthand","webpack://fidato-wealth/webpack/runtime/make namespace object","webpack://fidato-wealth/./src/js/main.js","webpack://fidato-wealth/./src/scss/main.scss"],"sourcesContent":["// package.json\nvar version = \"1.3.10\";\n\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n  return (n % d + d) % d;\n}\n\n// packages/core/src/animate.ts\nvar Animate = class {\n  isRunning = false;\n  value = 0;\n  from = 0;\n  to = 0;\n  currentTime = 0;\n  // These are instanciated in the fromTo method\n  lerp;\n  duration;\n  easing;\n  onUpdate;\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime) {\n    if (!this.isRunning) return;\n    let completed = false;\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime;\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n      completed = linearProgress >= 1;\n      const easedProgress = completed ? 1 : this.easing(linearProgress);\n      this.value = this.from + (this.to - this.from) * easedProgress;\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to;\n        completed = true;\n      }\n    } else {\n      this.value = this.to;\n      completed = true;\n    }\n    if (completed) {\n      this.stop();\n    }\n    this.onUpdate?.(this.value, completed);\n  }\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false;\n  }\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n    this.from = this.value = from;\n    this.to = to;\n    this.lerp = lerp2;\n    this.duration = duration;\n    this.easing = easing;\n    this.currentTime = 0;\n    this.isRunning = true;\n    onStart?.();\n    this.onUpdate = onUpdate;\n  }\n};\n\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n  let timer;\n  return function(...args) {\n    let context = this;\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = void 0;\n      callback.apply(context, args);\n    }, delay);\n  };\n}\n\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n  constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}) {\n    this.wrapper = wrapper;\n    this.content = content;\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue);\n      if (this.wrapper instanceof Window) {\n        window.addEventListener(\"resize\", this.debouncedResize, false);\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n        this.wrapperResizeObserver.observe(this.wrapper);\n      }\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n      this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  width = 0;\n  height = 0;\n  scrollHeight = 0;\n  scrollWidth = 0;\n  // These are instanciated in the constructor as they need information from the options\n  debouncedResize;\n  wrapperResizeObserver;\n  contentResizeObserver;\n  destroy() {\n    this.wrapperResizeObserver?.disconnect();\n    this.contentResizeObserver?.disconnect();\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener(\"resize\", this.debouncedResize, false);\n    }\n  }\n  resize = () => {\n    this.onWrapperResize();\n    this.onContentResize();\n  };\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n    } else {\n      this.width = this.wrapper.clientWidth;\n      this.height = this.wrapper.clientHeight;\n    }\n  };\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight;\n      this.scrollWidth = this.content.scrollWidth;\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight;\n      this.scrollWidth = this.wrapper.scrollWidth;\n    }\n  };\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n};\n\n// packages/core/src/emitter.ts\nvar Emitter = class {\n  events = {};\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event, ...args) {\n    let callbacks = this.events[event] || [];\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args);\n    }\n  }\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb]);\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i);\n    };\n  }\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event, callback) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i);\n  }\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {};\n  }\n};\n\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = { passive: false };\nvar VirtualScroll = class {\n  constructor(element, options = { wheelMultiplier: 1, touchMultiplier: 1 }) {\n    this.element = element;\n    this.options = options;\n    window.addEventListener(\"resize\", this.onWindowResize, false);\n    this.onWindowResize();\n    this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.addEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.addEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n  }\n  touchStart = {\n    x: 0,\n    y: 0\n  };\n  lastDelta = {\n    x: 0,\n    y: 0\n  };\n  window = {\n    width: 0,\n    height: 0\n  };\n  emitter = new Emitter();\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy();\n    window.removeEventListener(\"resize\", this.onWindowResize, false);\n    this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.removeEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchend\",\n      this.onTouchEnd,\n      listenerOptions\n    );\n  }\n  /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */\n  onTouchStart = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: 0,\n      y: 0\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX: 0,\n      deltaY: 0,\n      event\n    });\n  };\n  /** Event handler for 'touchmove' event */\n  onTouchMove = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX,\n      deltaY,\n      event\n    });\n  };\n  onTouchEnd = (event) => {\n    this.emitter.emit(\"scroll\", {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event\n    });\n  };\n  /** Event handler for 'wheel' event */\n  onWheel = (event) => {\n    let { deltaX, deltaY, deltaMode } = event;\n    const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n    const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n    deltaX *= multiplierX;\n    deltaY *= multiplierY;\n    deltaX *= this.options.wheelMultiplier;\n    deltaY *= this.options.wheelMultiplier;\n    this.emitter.emit(\"scroll\", { deltaX, deltaY, event });\n  };\n  onWindowResize = () => {\n    this.window = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  };\n};\n\n// packages/core/src/lenis.ts\nvar defaultEasing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t));\nvar Lenis = class {\n  _isScrolling = false;\n  // true when scroll is animating\n  _isStopped = false;\n  // true if user should not be able to scroll - enable/disable programmatically\n  _isLocked = false;\n  // same as isStopped but enabled/disabled when scroll reaches target\n  _preventNextNativeScrollEvent = false;\n  _resetVelocityTimeout = null;\n  __rafID = null;\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching;\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0;\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData = {};\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0;\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0;\n  /**\n   * The direction of the scroll\n   */\n  direction = 0;\n  /**\n   * The options passed to the lenis instance\n   */\n  options;\n  /**\n   * The target scroll value\n   */\n  targetScroll;\n  /**\n   * The animated scroll value\n   */\n  animatedScroll;\n  // These are instanciated here as they don't need information from the options\n  animate = new Animate();\n  emitter = new Emitter();\n  // These are instanciated in the constructor as they need information from the options\n  dimensions;\n  // This is not private because it's used in the Snap class\n  virtualScroll;\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaExponent = 1.7,\n    duration,\n    // in seconds\n    easing,\n    lerp: lerp2 = 0.1,\n    infinite = false,\n    orientation = \"vertical\",\n    // vertical, horizontal\n    gestureOrientation = orientation === \"horizontal\" ? \"both\" : \"vertical\",\n    // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false,\n    // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    __experimental__naiveDimensions = false\n  } = {}) {\n    window.lenisVersion = version;\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp: lerp2,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      __experimental__naiveDimensions\n    };\n    this.dimensions = new Dimensions(wrapper, content, { autoResize });\n    this.updateClassName();\n    this.targetScroll = this.animatedScroll = this.actualScroll;\n    this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n    this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.addEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.options.wrapper.addEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier\n    });\n    this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n    if (this.options.autoToggle) {\n      this.rootElement.addEventListener(\"transitionend\", this.onTransitionEnd, {\n        passive: true\n      });\n    }\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf);\n    }\n  }\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy();\n    this.options.wrapper.removeEventListener(\n      \"scroll\",\n      this.onNativeScroll,\n      false\n    );\n    this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    this.options.wrapper.removeEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.removeEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.virtualScroll.destroy();\n    this.dimensions.destroy();\n    this.cleanUpClassName();\n    if (this.__rafID) {\n      cancelAnimationFrame(this.__rafID);\n    }\n  }\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  off(event, callback) {\n    return this.emitter.off(event, callback);\n  }\n  onScrollEnd = (e) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n        e.stopPropagation();\n      }\n    }\n  };\n  dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent(\"scrollend\", {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true\n        }\n      })\n    );\n  };\n  onTransitionEnd = (event) => {\n    if (event.propertyName.includes(\"overflow\")) {\n      const property = this.isHorizontal ? \"overflow-x\" : \"overflow-y\";\n      const overflow = getComputedStyle(this.rootElement)[property];\n      if ([\"hidden\", \"clip\"].includes(overflow)) {\n        this.internalStop();\n      } else {\n        this.internalStart();\n      }\n    }\n  };\n  setScroll(scroll) {\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: \"instant\" });\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: \"instant\" });\n    }\n  }\n  onClick = (event) => {\n    const path = event.composedPath();\n    const anchor = path.find(\n      (node) => node instanceof HTMLAnchorElement && (node.getAttribute(\"href\")?.startsWith(\"#\") || node.getAttribute(\"href\")?.startsWith(\"/#\") || node.getAttribute(\"href\")?.startsWith(\"./#\"))\n    );\n    if (anchor) {\n      const id = anchor.getAttribute(\"href\");\n      if (id) {\n        const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n        let target = `#${id.split(\"#\")[1]}`;\n        if ([\"#\", \"/#\", \"./#\", \"#top\", \"/#top\", \"./#top\"].includes(id)) {\n          target = 0;\n        }\n        this.scrollTo(target, options);\n      }\n    }\n  };\n  onPointerDown = (event) => {\n    if (event.button === 1) {\n      this.reset();\n    }\n  };\n  onVirtualScroll = (data) => {\n    if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false)\n      return;\n    const { deltaX, deltaY, event } = data;\n    this.emitter.emit(\"virtual-scroll\", { deltaX, deltaY, event });\n    if (event.ctrlKey) return;\n    if (event.lenisStopPropagation) return;\n    const isTouch = event.type.includes(\"touch\");\n    const isWheel = event.type.includes(\"wheel\");\n    this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n    const isClickOrTap = deltaX === 0 && deltaY === 0;\n    const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n    if (isTapToStop) {\n      this.reset();\n      return;\n    }\n    const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n    if (isClickOrTap || isUnknownGesture) {\n      return;\n    }\n    let composedPath = event.composedPath();\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n    const prevent = this.options.prevent;\n    if (!!composedPath.find(\n      (node) => node instanceof HTMLElement && (typeof prevent === \"function\" && prevent?.(node) || node.hasAttribute?.(\"data-lenis-prevent\") || isTouch && node.hasAttribute?.(\"data-lenis-prevent-touch\") || isWheel && node.hasAttribute?.(\"data-lenis-prevent-wheel\") || this.options.allowNestedScroll && this.checkNestedScroll(node, { deltaX, deltaY }))\n    ))\n      return;\n    if (this.isStopped || this.isLocked) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      return;\n    }\n    const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n    if (!isSmooth) {\n      this.isScrolling = \"native\";\n      this.animate.stop();\n      event.lenisStopPropagation = true;\n      return;\n    }\n    let delta = deltaY;\n    if (this.options.gestureOrientation === \"both\") {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n    } else if (this.options.gestureOrientation === \"horizontal\") {\n      delta = deltaX;\n    }\n    if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n      event.lenisStopPropagation = true;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const isSyncTouch = isTouch && this.options.syncTouch;\n    const isTouchEnd = isTouch && event.type === \"touchend\";\n    const hasTouchInertia = isTouchEnd;\n    if (hasTouchInertia) {\n      delta = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent);\n    }\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...isSyncTouch ? {\n        lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n        // immediate: !hasTouchInertia,\n      } : {\n        lerp: this.options.lerp,\n        duration: this.options.duration,\n        easing: this.options.easing\n      }\n    });\n  };\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize();\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.emit();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout);\n      this._resetVelocityTimeout = null;\n    }\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false;\n      return;\n    }\n    if (this.isScrolling === false || this.isScrolling === \"native\") {\n      const lastScroll = this.animatedScroll;\n      this.animatedScroll = this.targetScroll = this.actualScroll;\n      this.lastVelocity = this.velocity;\n      this.velocity = this.animatedScroll - lastScroll;\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      );\n      if (!this.isStopped) {\n        this.isScrolling = \"native\";\n      }\n      this.emit();\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity;\n          this.velocity = 0;\n          this.isScrolling = false;\n          this.emit();\n        }, 400);\n      }\n    }\n  };\n  reset() {\n    this.isLocked = false;\n    this.isScrolling = false;\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.lastVelocity = this.velocity = 0;\n    this.animate.stop();\n  }\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty(\"overflow\");\n      return;\n    }\n    this.internalStart();\n  }\n  internalStart() {\n    if (!this.isStopped) return;\n    this.reset();\n    this.isStopped = false;\n    this.emit();\n  }\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty(\"overflow\", \"clip\");\n      return;\n    }\n    this.internalStop();\n  }\n  internalStop() {\n    if (this.isStopped) return;\n    this.reset();\n    this.isStopped = true;\n    this.emit();\n  }\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time) => {\n    const deltaTime = time - (this.time || time);\n    this.time = time;\n    this.animate.advance(deltaTime * 1e-3);\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf);\n    }\n  };\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(target, {\n    offset = 0,\n    immediate = false,\n    lock = false,\n    duration = this.options.duration,\n    easing = this.options.easing,\n    lerp: lerp2 = this.options.lerp,\n    onStart,\n    onComplete,\n    force = false,\n    // scroll even if stopped\n    programmatic = true,\n    // called from outside of the class\n    userData\n  } = {}) {\n    if ((this.isStopped || this.isLocked) && !force) return;\n    if (typeof target === \"string\" && [\"top\", \"left\", \"start\"].includes(target)) {\n      target = 0;\n    } else if (typeof target === \"string\" && [\"bottom\", \"right\", \"end\"].includes(target)) {\n      target = this.limit;\n    } else {\n      let node;\n      if (typeof target === \"string\") {\n        node = document.querySelector(target);\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        node = target;\n      }\n      if (node) {\n        if (this.options.wrapper !== window) {\n          const wrapperRect = this.rootElement.getBoundingClientRect();\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n        }\n        const rect = node.getBoundingClientRect();\n        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n      }\n    }\n    if (typeof target !== \"number\") return;\n    target += offset;\n    target = Math.round(target);\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll;\n        const distance = target - this.animatedScroll;\n        if (distance > this.limit / 2) {\n          target = target - this.limit;\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit;\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit);\n    }\n    if (target === this.targetScroll) {\n      onStart?.(this);\n      onComplete?.(this);\n      return;\n    }\n    this.userData = userData ?? {};\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target;\n      this.setScroll(this.scroll);\n      this.reset();\n      this.preventNextNativeScrollEvent();\n      this.emit();\n      onComplete?.(this);\n      this.userData = {};\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent();\n      });\n      return;\n    }\n    if (!programmatic) {\n      this.targetScroll = target;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp: lerp2,\n      onStart: () => {\n        if (lock) this.isLocked = true;\n        this.isScrolling = \"smooth\";\n        onStart?.(this);\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = \"smooth\";\n        this.lastVelocity = this.velocity;\n        this.velocity = value - this.animatedScroll;\n        this.direction = Math.sign(this.velocity);\n        this.animatedScroll = value;\n        this.setScroll(this.scroll);\n        if (programmatic) {\n          this.targetScroll = value;\n        }\n        if (!completed) this.emit();\n        if (completed) {\n          this.reset();\n          this.emit();\n          onComplete?.(this);\n          this.userData = {};\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent();\n          });\n          this.preventNextNativeScrollEvent();\n        }\n      }\n    });\n  }\n  preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true;\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false;\n    });\n  }\n  checkNestedScroll(node, { deltaX, deltaY }) {\n    const time = Date.now();\n    const cache = node._lenis ??= {};\n    let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;\n    const gestureOrientation = this.options.gestureOrientation;\n    if (time - (cache.time ?? 0) > 2e3) {\n      cache.time = Date.now();\n      const computedStyle = window.getComputedStyle(node);\n      cache.computedStyle = computedStyle;\n      const overflowXString = computedStyle.overflowX;\n      const overflowYString = computedStyle.overflowY;\n      hasOverflowX = [\"auto\", \"overlay\", \"scroll\"].includes(overflowXString);\n      hasOverflowY = [\"auto\", \"overlay\", \"scroll\"].includes(overflowYString);\n      cache.hasOverflowX = hasOverflowX;\n      cache.hasOverflowY = hasOverflowY;\n      if (!hasOverflowX && !hasOverflowY) return false;\n      if (gestureOrientation === \"vertical\" && !hasOverflowY) return false;\n      if (gestureOrientation === \"horizontal\" && !hasOverflowX) return false;\n      scrollWidth = node.scrollWidth;\n      scrollHeight = node.scrollHeight;\n      clientWidth = node.clientWidth;\n      clientHeight = node.clientHeight;\n      isScrollableX = scrollWidth > clientWidth;\n      isScrollableY = scrollHeight > clientHeight;\n      cache.isScrollableX = isScrollableX;\n      cache.isScrollableY = isScrollableY;\n      cache.scrollWidth = scrollWidth;\n      cache.scrollHeight = scrollHeight;\n      cache.clientWidth = clientWidth;\n      cache.clientHeight = clientHeight;\n    } else {\n      isScrollableX = cache.isScrollableX;\n      isScrollableY = cache.isScrollableY;\n      hasOverflowX = cache.hasOverflowX;\n      hasOverflowY = cache.hasOverflowY;\n      scrollWidth = cache.scrollWidth;\n      scrollHeight = cache.scrollHeight;\n      clientWidth = cache.clientWidth;\n      clientHeight = cache.clientHeight;\n    }\n    if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) {\n      return false;\n    }\n    if (gestureOrientation === \"vertical\" && (!hasOverflowY || !isScrollableY))\n      return false;\n    if (gestureOrientation === \"horizontal\" && (!hasOverflowX || !isScrollableX))\n      return false;\n    let orientation;\n    if (gestureOrientation === \"horizontal\") {\n      orientation = \"x\";\n    } else if (gestureOrientation === \"vertical\") {\n      orientation = \"y\";\n    } else {\n      const isScrollingX = deltaX !== 0;\n      const isScrollingY = deltaY !== 0;\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = \"x\";\n      }\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = \"y\";\n      }\n    }\n    if (!orientation) return false;\n    let scroll, maxScroll, delta, hasOverflow, isScrollable;\n    if (orientation === \"x\") {\n      scroll = node.scrollLeft;\n      maxScroll = scrollWidth - clientWidth;\n      delta = deltaX;\n      hasOverflow = hasOverflowX;\n      isScrollable = isScrollableX;\n    } else if (orientation === \"y\") {\n      scroll = node.scrollTop;\n      maxScroll = scrollHeight - clientHeight;\n      delta = deltaY;\n      hasOverflow = hasOverflowY;\n      isScrollable = isScrollableY;\n    } else {\n      return false;\n    }\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;\n    return willScroll && hasOverflow && isScrollable;\n  }\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n    }\n  }\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === \"horizontal\";\n  }\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    const wrapper = this.options.wrapper;\n    return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n  }\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n  }\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    return this.limit === 0 ? 1 : this.scroll / this.limit;\n  }\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling;\n  }\n  set isScrolling(value) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped;\n  }\n  set isStopped(value) {\n    if (this._isStopped !== value) {\n      this._isStopped = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    if (this._isLocked !== value) {\n      this._isLocked = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === \"smooth\";\n  }\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = \"lenis\";\n    if (this.options.autoToggle) className += \" lenis-autoToggle\";\n    if (this.isStopped) className += \" lenis-stopped\";\n    if (this.isLocked) className += \" lenis-locked\";\n    if (this.isScrolling) className += \" lenis-scrolling\";\n    if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n    return className;\n  }\n  updateClassName() {\n    this.cleanUpClassName();\n    this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n  }\n  cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n  }\n};\nexport {\n  Lenis as default\n};\n//# sourceMappingURL=lenis.mjs.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import Lenis from 'lenis';\n\n// Add your JavaScript code here\nclass FidatoPluginJS {\n\n    constructor() {\n        this.init();\n    }\n\n    init() {\n\n        // ----------------------\n        // OPTIMIZED LENIS with Hash Scrolling Integration\n        // ----------------------\n\n        // Prevent initial browser hash jump\n        (function preventInitialHashJump() {\n            if (window.location.hash) {\n                window.pendingHash = window.location.hash\n                history.replaceState(null, null, window.location.pathname + window.location.search)\n            }\n        })()\n\n        // Throttle function to limit execution frequency\n        function throttle(func, delay) {\n            let lastCall = 0\n            let scheduled = false\n            \n            return function(...args) {\n                const now = Date.now()\n                \n                if (now - lastCall >= delay) {\n                    lastCall = now\n                    func.apply(this, args)\n                } else if (!scheduled) {\n                    scheduled = true\n                    setTimeout(() => {\n                        scheduled = false\n                        lastCall = Date.now()\n                        func.apply(this, args)\n                    }, delay - (now - lastCall))\n                }\n            }\n        }\n\n        // Use Intersection Observer for visibility detection instead of scroll calculations\n        let observer = null\n        function setupIntersectionObserver() {\n            // Clean up existing observer\n            if (observer) {\n                observer.disconnect()\n            }\n\n            const options = {\n                rootMargin: '50px 0px',\n                threshold: [0, 0.1]\n            }\n\n            observer = new IntersectionObserver((entries) => {\n                entries.forEach(entry => {\n                    const className = entry.target.dataset.scrollClass\n                    if (className) {\n                        if (entry.isIntersecting) {\n                            entry.target.classList.add(className)\n                        } else if (entry.target.hasAttribute('data-scroll-repeat')) {\n                            entry.target.classList.remove(className)\n                        }\n                    }\n                })\n            }, options)\n\n            // Observe elements with scroll-class\n            document.querySelectorAll('[data-scroll-class]').forEach(el => {\n                observer.observe(el)\n            })\n        }\n\n        // Add animation to all dividers\n        const dividers = document.querySelectorAll('.elementor-widget-divider')\n        dividers.forEach(divider => {\n            divider.setAttribute('data-scroll', '')\n            divider.setAttribute('data-scroll-repeat', '')\n            divider.setAttribute('data-scroll-class', 'loco-in-view')\n        })\n\n        // Add scroll tracking to elements with IDs\n        document.querySelectorAll('[id]').forEach(element => {\n            element.setAttribute('data-scroll', '')\n            element.setAttribute('data-scroll-id', element.id)\n        })\n\n        // Initialize Lenis (no manual RAF loop needed with autoRaf)\n        const lenis = new Lenis({\n            autoRaf: true,\n            lerp: 0.15,\n            wheelMultiplier: 1,\n            touchMultiplier: 2,\n            infinite: false,\n            allowNestedScroll: true,\n\n\n        })\n\n        // Setup Intersection Observer for class toggling\n        setupIntersectionObserver()\n\n        // Parallax handling with caching and throttling\n        let parallaxCache = new Map()\n        let rafId = null\n\n        function cacheParallaxElements() {\n            // Clear previous cache\n            parallaxCache.clear()\n            \n            document.querySelectorAll('[data-scroll-speed]').forEach(el => {\n                const rect = el.getBoundingClientRect()\n                const scrollTop = window.scrollY || document.documentElement.scrollTop\n                const speed = parseFloat(el.dataset.scrollSpeed) || 0\n                \n                parallaxCache.set(el, {\n                    initialOffset: rect.top + scrollTop,\n                    height: rect.height,\n                    speed: speed\n                })\n            })\n        }\n\n        // Throttled parallax update (16ms = ~60fps)\n        const updateParallax = throttle((scrollY) => {\n            // Cancel any pending animation frame\n            if (rafId) {\n                cancelAnimationFrame(rafId)\n            }\n            \n            rafId = requestAnimationFrame(() => {\n                const windowHeight = window.innerHeight\n                const viewportCenter = windowHeight / 2 + scrollY\n\n                parallaxCache.forEach((data, el) => {\n                    const elCenter = data.initialOffset + data.height / 2\n                    const distanceFromCenter = elCenter - viewportCenter\n                    \n                    // Only update if element is near viewport\n                    if (Math.abs(distanceFromCenter) < windowHeight * 1.5) {\n                        let y = distanceFromCenter * data.speed / 10\n                        y = Math.round(y * 100) / 100\n                        \n                        // Use will-change for better performance\n                        if (!el.style.willChange) {\n                            el.style.willChange = 'transform'\n                        }\n                        el.style.transform = `translate3d(0, ${y}px, 0)`\n                    }\n                })\n                \n                rafId = null\n            })\n        }, 32)\n\n        // Cache elements initially\n        cacheParallaxElements()\n\n        // Debounced resize handler\n        let resizeTimeout\n        window.addEventListener('resize', () => {\n            clearTimeout(resizeTimeout)\n            resizeTimeout = setTimeout(() => {\n                cacheParallaxElements()\n                setupIntersectionObserver()\n            }, 250)\n        }, { passive: true })\n\n        // Only attach scroll listener if parallax elements exist\n        if (parallaxCache.size > 0) {\n            lenis.on('scroll', (e) => {\n                updateParallax(e.scroll)\n            })\n        }\n\n        // ----------------------\n        // Hash Scrolling Integration\n        // ----------------------\n\n        // Handle anchor link clicks (delegated for performance)\n        document.addEventListener('click', (e) => {\n            const anchor = e.target.closest('a[href^=\"#\"]')\n            if (!anchor) return\n            \n            e.preventDefault()\n            const targetId = anchor.getAttribute('href')\n            if (targetId === '#') return\n            \n            const targetEl = document.querySelector(targetId)\n            if (targetEl) {\n                lenis.scrollTo(targetEl, {\n                    offset: -100,\n                    duration: 1.2,\n                    easing: (t) => 1 - Math.pow(1 - t, 3),\n                    onComplete: () => {\n                        history.replaceState(null, null, targetId)\n                    }\n                })\n            }\n        }, { passive: false })\n\n        // Handle pending hash after page loads\n        function handlePendingHash() {\n            if (window.pendingHash) {\n                const targetEl = document.querySelector(window.pendingHash)\n                if (targetEl) {\n                    // Use requestIdleCallback for non-critical initial scroll\n                    const scrollToHash = () => {\n                        lenis.scrollTo(targetEl, {\n                            offset: -100,\n                            duration: 1.2,\n                            easing: (t) => 1 - Math.pow(1 - t, 3),\n                            onComplete: () => {\n                                history.replaceState(null, null, \n                                    window.location.pathname + \n                                    window.location.search + \n                                    window.pendingHash)\n                                delete window.pendingHash\n                            }\n                        })\n                    }\n                    \n                    if ('requestIdleCallback' in window) {\n                        requestIdleCallback(scrollToHash, { timeout: 500 })\n                    } else {\n                        setTimeout(scrollToHash, 200)\n                    }\n                }\n            }\n        }\n\n        // Initialize hash handling when everything is loaded\n        window.addEventListener('load', handlePendingHash, { once: true })\n\n        // Cleanup on page unload to prevent memory leaks\n        window.addEventListener('beforeunload', () => {\n            if (observer) {\n                observer.disconnect()\n            }\n            if (lenis) {\n                lenis.destroy()\n            }\n            parallaxCache.clear()\n        })\n\n\n\n        // Wait until DOM is ready\n        document.addEventListener(\"DOMContentLoaded\", () => {\n            console.log(\"DOM loaded\");\n\n\n            // Initialize the Swiper with proper configuration to avoid scroll conflicts\n            var overflowSwiper = new Swiper('.overflowSwiper', {\n                slidesPerView: 1.33,\n                centeredSlides: true,\n                loop: false,\n                speed: 500,\n                spaceBetween: 36,\n                mousewheel: false,\n                keyboard: {\n                    enabled: true,\n                    onlyInViewport: true,\n                },\n                navigation: {\n                    nextEl: '.overflow-swiper-button-next',\n                    prevEl: '.overflow-swiper-button-prev',\n                },\n                breakpoints: {\n                    768: {\n                        centeredSlides: false,\n                        slidesPerView: 2,\n                    },\n                    1024: {\n                        centeredSlides: false,\n                        slidesPerView: 3,\n                    }\n                },\n            });\n\n            var blueNumericSwiper = new Swiper('.blueNumericSwiper', {\n                slidesPerView: 1.33,\n                centeredSlides: true,\n                loop: false,\n                speed: 500,\n                spaceBetween: 16,\n                mousewheel: false,\n                keyboard: {\n                    enabled: true,\n                    onlyInViewport: true,\n                },\n                navigation: {\n                    nextEl: '.blue-numeric-swiper-button-next',\n                    prevEl: '.blue-numeric-swiper-button-prev',\n                },\n                breakpoints: {\n                    768: {\n                        slidesPerView: 2,\n                        centeredSlides: false,\n                        spaceBetween: 36,\n                    },\n                    1024: {\n                        slidesPerView: 3,\n                        centeredSlides: false,\n                        spaceBetween: 36,\n                    }\n                },\n            });\n\n            var blueValuesSwiper = new Swiper('.blueValuesSwiper', {\n                slidesPerView: 1.33,\n                centeredSlides: true,\n                loop: false,\n                speed: 500,\n                spaceBetween: 16,\n                mousewheel: false,\n                keyboard: {\n                    enabled: true,\n                    onlyInViewport: true,\n                },\n                navigation: {\n                    nextEl: '.blue-values-swiper-button-next',\n                    prevEl: '.blue-values-swiper-button-prev',\n                },\n                breakpoints: {\n                    768: {\n                        slidesPerView: 2,\n                        centeredSlides: false,\n                        spaceBetween: 36,\n                    },\n                    1024: {\n                        slidesPerView: 3,\n                        centeredSlides: false,\n                        spaceBetween: 36,\n                    }\n                },\n            });\n\n            var learningCenterSwiper = new Swiper('.learningCenterSwiper', {\n                slidesPerView: 1,\n                centeredSlides: false,\n                loop: false,\n                speed: 500,\n                spaceBetween: 36,\n                mousewheel: false,\n                keyboard: {\n                    enabled: true,\n                    onlyInViewport: true,\n                },\n                navigation: {\n                    nextEl: '.learning-center-swiper-button-next',\n                    prevEl: '.learning-center-swiper-button-prev',\n                },\n            });\n\n            const teamCarousel = document.querySelector('.team-carousel');\n        \n            if (teamCarousel) {\n                const observer = new IntersectionObserver((entries, observer) => {\n                    entries.forEach(entry => {\n                        if (entry.isIntersecting) {\n                            // Initialize Swiper once visible\n                            \n                            initTeamSwiper();\n                            observer.unobserve(entry.target); // stop observing once initialized\n                        }\n                    });\n                }, {\n                    threshold: 0.2 // adjust: 0.2 = 20% visible before init\n                });\n        \n                observer.observe(teamCarousel);\n            }\n        \n            function initTeamSwiper() {\n                var teamSwiper = new Swiper('.teamSwiper', {\n                    slidesPerView: 1.5,\n                    loop: true,\n                    speed: 750,\n                    centeredSlides: true,\n                    spaceBetween: 32,\n                    mousewheel: false,\n                    allowTouchMove: true,\n                    initialSlide: 0,\n                    autoplay: {\n                        delay: 3500,\n                        disableOnInteraction: false,\n                    },\n                    keyboard: {\n                        enabled: true,\n                        onlyInViewport: true,\n                    },\n                    navigation: {\n                        nextEl: '.team-swiper-button-next',\n                        prevEl: '.team-swiper-button-prev',\n                    },\n                    breakpoints: {\n                        768: {\n                            slidesPerView: 2,\n                            spaceBetween: 44,\n                            centeredSlides: true,\n                            allowTouchMove: true,\n                        },\n                        1024: {\n                            slidesPerView: 3,\n                            spaceBetween: 100,\n                            centeredSlides: false,\n                            //allowTouchMove: false\n                        }\n                    },\n                    // loopAdditionalSlides: 12,\n                    // loopedSlides: 12,\n                });\n        \n                // Button navigation\n                const nextBtn = document.querySelector('.team-swiper-button-next');\n                const prevBtn = document.querySelector('.team-swiper-button-prev');\n        \n                if (nextBtn) {\n                    nextBtn.addEventListener('click', () => teamSwiper.slideNext());\n                }\n                if (prevBtn) {\n                    prevBtn.addEventListener('click', () => teamSwiper.slidePrev());\n                }\n        \n                // Team panel handlers\n                document.querySelectorAll('.team-carousel .swiper-slide .link').forEach(link => {\n                    link.addEventListener('click', function(e) {\n                        e.preventDefault();\n\n                        lenis.stop();\n                        \n                        const linkHref = this.getAttribute('href').toString();\n                        const targetPanel = document.querySelector(linkHref);\n                        const teamPanelOverlay = document.querySelector('.panel-container');\n                        \n                        if (targetPanel) {\n                            targetPanel.classList.add('active');\n                        }\n\n                        if (teamPanelOverlay) {\n                            teamPanelOverlay.classList.add('active');\n                            teamPanelOverlay.style.top = scrollTop + 'px';\n                        }\n\n                        // enable scroll within the panel content\n                        const panelContent = document.querySelector('.team-panel--content.active .team-panel--body');\n                        if (panelContent) {\n                            panelContent.style.overflowY = 'auto';\n                        }\n                    \n\n                        \n\n                        \n\n                    });\n                });\n\n                document.querySelectorAll('.team-carousel .swiper-slide .video-icon').forEach(link => {\n                    link.addEventListener('click', function(e) {\n                        e.preventDefault();\n\n                        lenis.stop();\n                        \n                        const linkHref = this.getAttribute('href').toString();\n                        const targetPanel = document.querySelector(linkHref);\n                        const teamPanelOverlay = document.querySelector('.panel-container');\n                        \n                        if (targetPanel) {\n                            targetPanel.classList.add('active');\n                        }\n\n                        if (teamPanelOverlay) {\n                            teamPanelOverlay.classList.add('active');\n                            teamPanelOverlay.classList.add('video-view');\n                            teamPanelOverlay.style.top = scrollTop + 'px';\n                        }\n                        \n                    });\n                });\n\n                // Function to close team panel modal\n                function closeTeamPanel() {\n                    const teamPanelOverlay = document.querySelector('.panel-container');\n\n                    if (teamPanelOverlay) {\n                        teamPanelOverlay.classList.remove('active');\n                        teamPanelOverlay.classList.remove('video-view');\n                    }\n                    \n                    document.querySelectorAll('.team-panel--content').forEach(panel => {\n                        panel.classList.remove('active');\n                    });\n\n                    lenis.start();\n\n                }\n\n                // Close button handler\n                const closeBtn = document.querySelector('.team-panel--header .close');\n                if (closeBtn) {\n                    closeBtn.addEventListener('click', closeTeamPanel);\n                }\n\n                // Overlay click handler\n                const overlay = document.querySelector('.team-panel--overlay');\n                if (overlay) {\n                    overlay.addEventListener('click', closeTeamPanel);\n                }\n\n                // Team carousel mouse event handlers\n                const teamCarousel = document.querySelector('.team-carousel');\n            }\n\n\n\n\n\n        });\n    }\n}\n\nnew FidatoPluginJS();","// extracted by mini-css-extract-plugin\nexport {};"],"names":["Lenis","FidatoPluginJS","_classCallCheck","init","_createClass","key","value","preventInitialHashJump","window","location","hash","pendingHash","history","replaceState","pathname","search","throttle","func","delay","lastCall","scheduled","_this","_len","arguments","length","args","Array","_key","now","Date","apply","setTimeout","observer","setupIntersectionObserver","disconnect","options","rootMargin","threshold","IntersectionObserver","entries","forEach","entry","className","target","dataset","scrollClass","isIntersecting","classList","add","hasAttribute","remove","document","querySelectorAll","el","observe","dividers","divider","setAttribute","element","id","lenis","autoRaf","lerp","wheelMultiplier","touchMultiplier","infinite","allowNestedScroll","parallaxCache","Map","rafId","cacheParallaxElements","clear","rect","getBoundingClientRect","scrollTop","scrollY","documentElement","speed","parseFloat","scrollSpeed","set","initialOffset","top","height","updateParallax","cancelAnimationFrame","requestAnimationFrame","windowHeight","innerHeight","viewportCenter","data","elCenter","distanceFromCenter","Math","abs","y","round","style","willChange","transform","concat","resizeTimeout","addEventListener","clearTimeout","passive","size","on","e","scroll","anchor","closest","preventDefault","targetId","getAttribute","targetEl","querySelector","scrollTo","offset","duration","easing","t","pow","onComplete","handlePendingHash","scrollToHash","requestIdleCallback","timeout","once","destroy","console","log","overflowSwiper","Swiper","slidesPerView","centeredSlides","loop","spaceBetween","mousewheel","keyboard","enabled","onlyInViewport","navigation","nextEl","prevEl","breakpoints","blueNumericSwiper","blueValuesSwiper","learningCenterSwiper","teamCarousel","initTeamSwiper","unobserve","teamSwiper","allowTouchMove","initialSlide","autoplay","disableOnInteraction","nextBtn","prevBtn","slideNext","slidePrev","link","stop","linkHref","toString","targetPanel","teamPanelOverlay","panelContent","overflowY","closeTeamPanel","panel","start","closeBtn","overlay"],"sourceRoot":""}